create database olist;
use olist;

# Cleaning the data:

alter table products 
add column product_category_name_English varchar(100);

update products p
join `category name translation` c
on p.product_category_name = c.product_category_name 
set p.product_category_name_English = c.product_category_name_english;

select count(*) from products p where p.product_category_name_English = '';

select distinct(p.product_category_name_English) from products p
order by p.product_category_name_English ; 

select p.product_category_name, p.product_category_name_English from products p
where p.product_category_name = 'portateis_cozinha_e_preparadores_de_alimentos';

select p.product_category_name, p.product_category_name_English from products p 
where p.product_category_name_English = 'N/A';

update products p
set p.product_category_name_English = 'portable kitchens and food preparers'
where p.product_category_name = 'portateis_cozinha_e_preparadores_de_alimentos';

update products p
set p.product_category_name_English = 'pc-game'
where p.product_category_name = 'pc_gamer';

________________________________________________________________________________________________________

#Q1: What is the total revenue generated by Olist, and how has it changed over time?
select
	min(o.order_purchase_timestamp) start_date,
	max(o.order_purchase_timestamp) end_date
from 
	orders o;

#Invalid orders:
select
	o.order_status,
	count(*) as invalid_orders
from 
	orders o
where
	o.order_delivered_customer_date = ''
group by
	o.order_status;


# Total Revenue:
select
	round(sum(p.payment_value),0) as Toatal_Revenue
from 
	orders o join payments p 
on 	
	o.order_id = p.order_id
where
	o.order_status <> 'canceled' and 
	o.order_delivered_customer_date <> '';	
 
#Change of revenue over time:
select 
	year(o.order_delivered_customer_date) as the_year,
	month(o.order_delivered_customer_date) as the_month,
	Quarter(o.order_delivered_customer_date) as the_quarter,
	round(sum(p.payment_value), 0) as total_revenue
from
	orders o 
join 
	payments p
on o.order_id = p.order_id
where 
	o.order_status <> 'canceled' and 
	o.order_delivered_customer_date <> ''
group by 
	the_year, the_month, the_quarter
order by
	the_year, the_month, the_quarter;

________________________________________________________________________________________________________

#Q2: How many orders were placed on Olist, and how does this vary by month or season?

# Total orders:
select
	count(*) as Toatal_Orders
from 
	orders o
where
	o.order_status <> 'canceled' and 
	o.order_delivered_customer_date <> '';	
 
#Change of no. of orders by month:
select 
	year(o.order_delivered_customer_date) as the_year,
	month(o.order_delivered_customer_date) as the_month,
	count(*) as no_of_orders
from
	orders o 
where 
	o.order_status <> 'canceled' and 
	o.order_delivered_customer_date <> ''
group by 
	the_year, the_month
order by
	the_year, the_month;

#Change of no. of orders by Quarter:
select 
	year(o.order_delivered_customer_date) as the_year,
	quarter(o.order_delivered_customer_date) as the_quarter,
	count(*) as no_of_orders
from
	orders o 
where 
	o.order_status <> 'canceled' and 
	o.order_delivered_customer_date <> ''
group by 
	the_year, the_quarter
order by
	the_year, the_quarter;

________________________________________________________________________________________________________

#Q3: What are the most popular product categories on Olist, and how do their sales volumes compare to each other?

select 
	i.order_id, count(i.product_id) 
from 
	items i 
group by 
	i.order_id 
order by 
	count(i.product_id) desc;
# This shows that one order_id has ordered multiple products. So, to count each product seperately
# I am using here cross join to find the percentage of each product category.

select 	
	pp.product_category_name_English as category_name,
	count(o.order_id) as No_of_orders,
	round((count(o.order_id)/(total_orders.total_no_of_orders)) * 100,2) as percentage
from
	orders o
join
	items i on o.order_id = i.order_id
join 
	(select
		p.product_id,
		p.product_category_name_English
	from 
		products p
	) as pp on i.product_id = pp.product_id 
cross join
	(select 
		count(o.order_id) as total_no_of_orders
	from
		orders o
	where
		o.order_status <> 'canceled' and 
		o.order_delivered_customer_date <> '') as total_orders
where 
	o.order_status <> 'canceled' and 
	o.order_delivered_customer_date <> ''
group by 
	category_name, total_no_of_orders
order by
	percentage desc;

________________________________________________________________________________________________________

#Q4: What is the average order value (AOV) on Olist, and how does this vary by product category or payment method?

# Average Order Value - AOV = total revenue / total orders
# Cost Per Order - CPO = total cost of product / total orders

select
	round(sum(op.payment_value) / count(o.order_id)) as AOV,
	round(sum(oc.cost) / count(o.order_id)) as CPO,
	round(round(sum(op.payment_value) / count(o.order_id)) - 
			round(sum(oc.cost) / count(o.order_id)) , 2) as profit_per_order
from 
	orders o 
join
	(select
		o2.order_id,
		sum(p.payment_value) as payment_value
	from 
		orders o2 
	join 
		payments p on o2.order_id = p.order_id
	where
		o2.order_status <> 'canceled' and 
		o2.order_delivered_customer_date <> ''
	group by 
		o2.order_id
	) as op on o.order_id = op.order_id
join 
	(
	select 
		o2.order_id,
		sum(i.price + i.freight_value) as cost
	from 
		orders o2 
	join
		items i on o2.order_id = i.order_id
	where 
		o2.order_status <> 'canceled' and 
		o2.order_delivered_customer_date <> ''
	group by 
		o2.order_id
	) as oc on o.order_id = oc.order_id;
	
# Profit per order:
select
	o.order_id,
	round(sum(op.payment_value) / count(o.order_id)) as AOV,
	round(sum(oc.cost) / count(o.order_id)) as CPO,
	round(round(sum(op.payment_value) / count(o.order_id)) - 
			round(sum(oc.cost) / count(o.order_id)) , 2) as profit_per_order
from 
	orders o 
join
	(select
		o2.order_id,
		sum(p.payment_value) as payment_value
	from 
		orders o2 
	join 
		payments p on o2.order_id = p.order_id
	where
		o2.order_status <> 'canceled' and 
		o2.order_delivered_customer_date <> ''
	group by 
		o2.order_id
	) as op on o.order_id = op.order_id
join 
	(
	select 
		o2.order_id,
		sum(i.price + i.freight_value) as cost
	from 
		orders o2 
	join
		items i on o2.order_id = i.order_id
	where 
		o2.order_status <> 'canceled' and 
		o2.order_delivered_customer_date <> ''
	group by 
		o2.order_id
	) as oc on o.order_id = oc.order_id
group by 
	o.order_id 
having 
	profit_per_order > 0
order by 
	profit_per_order desc;

# AOV on product category:
select 
	p.product_category_name_English as product_name,
	count(profit.order_id) as profit_count
from 
	items i 
join
	products p on i.product_id = p.product_id
join 
	(
	select
		o.order_id,
		round(sum(op.payment_value) / count(o.order_id)) as AOV,
		round(sum(oc.cost) / count(o.order_id)) as CPO,
		round(round(sum(op.payment_value) / count(o.order_id)) - 
			round(sum(oc.cost) / count(o.order_id)) , 2) as profit_per_order
	from 
		orders o 
	join
		(select
			o2.order_id,
			sum(p.payment_value) as payment_value
		from 
			orders o2 
		join 
			payments p on o2.order_id = p.order_id
		where
			o2.order_status <> 'canceled' and 
			o2.order_delivered_customer_date <> ''
		group by 
			o2.order_id
		) as op on o.order_id = op.order_id
	join 
		(
		select 
			o2.order_id,
			sum(i.price + i.freight_value) as cost
		from 
			orders o2 
		join
			items i on o2.order_id = i.order_id
		where 
			o2.order_status <> 'canceled' and 
			o2.order_delivered_customer_date <> ''
		group by 
			o2.order_id
		) as oc on o.order_id = oc.order_id
	group by 
		o.order_id 
	having 
		profit_per_order > 0
	order by 
		profit_per_order desc
	) as profit on i.order_id = profit.order_id
group by 
	product_name
order by
	profit_count desc; 

# AOV by payment method:
select
	p.payment_type,
	round(sum(p.payment_value)/count(distinct o.order_id),0) as AOV
from 
	payments p 
join
	orders o on p.order_id = o.order_id 
where
	o.order_status <> 'canceled' and 
	o.order_delivered_customer_date <> ''
group by 
	p.payment_type 
order by 
	AOV desc;

________________________________________________________________________________________________________

#Q5: How many sellers are active on Olist, and how does this number change over time?

# Number of sellers:
select 
	count(distinct s.seller_id) as total_sellers
from
	sellers s;

select distinct(order_id), count(i.seller_id) from items i group by order_id order by count(i.seller_id) desc; 
# Here some of the order_id's contain multiple seller_id's

#A seller can be considered active if they added a new listing within the last 30 days.

# First I will find distinct seller_id's by order_id's with order_items count:
select
	s2.seller_id,
	i.order_id,
	count(i.order_item_id ) as order_item_count
from 
	items i 
join
	(
	select
		i2.order_id as order_id ,
		count(distinct i2.seller_id) as distinct_seller_count
	from 	
		items i2 
	group by
		order_id
	) as s1 on i.order_id = s1.order_id
join 
	(
	select
		i2.order_id,
		i2.seller_id
	from 
		items i2 
	group by 
		order_id, seller_id 
	) as s2 on i.order_id = s2.order_id
group by 
	i.order_id, s2.seller_id 
order by 
	s2.seller_id, i.order_id ;

# To find customers previous order purchase date:
select 
	sd.seller_id,
	o.order_id,
	o.order_purchase_timestamp,
	lag(o.order_purchase_timestamp ,1)
		over(partition by sd.seller_id order by o.order_purchase_timestamp) as previous_order_date
from 
	orders o 
join 
	(select
		s2.seller_id,
		i.order_id,
		count(i.order_item_id ) as order_item_count
	from 
		items i 
	join
		(
		select
			i2.order_id as order_id ,
			count(distinct i2.seller_id) as distinct_seller_count
		from 
			items i2 
		group by
			i2.order_id
		) as s1 on i.order_id = s1.order_id
	join 
		(
		select
			i2.order_id,
			i2.seller_id
		from 
			items i2 
		group by 
			order_id, seller_id 
		) as s2 on i.order_id = s2.order_id
	group by 
		i.order_id, s2.seller_id 
	order by 
		s2.seller_id, i.order_id
	) as sd on o.order_id = sd.order_id
where 
	o.order_status <> 'canceled' and 
	o.order_delivered_customer_date <> ''
order by 
	sd.seller_id, o.order_purchase_timestamp desc;

# Days between last purchase and previous purchase
select
	seller_id,
	datediff(max(dates.order_purchase_timestamp), max(previous_order_date)) as days_between_orders
from 
	(select 
		sd.seller_id,
		o.order_id,
		o.order_purchase_timestamp,
		lag(o.order_purchase_timestamp ,1)
			over(partition by sd.seller_id order by o.order_purchase_timestamp) as previous_order_date
	from 
		orders o 
	join 
		(
			select
			s2.seller_id,
			i.order_id,
			count(i.order_item_id ) as order_item_count
		from 
			items i 
		join
			(
			select
				i2.order_id as order_id ,
				count(distinct i2.seller_id) as distinct_seller_count
			from 
				items i2 
			group by
				i2.order_id
			) as s1 on i.order_id = s1.order_id
		join 
			(
			select
				i2.order_id,
				i2.seller_id
			from 
				items i2 
			group by 
				order_id, seller_id 
			) as s2 on i.order_id = s2.order_id
		group by 
			i.order_id, s2.seller_id 
		order by 
			s2.seller_id, i.order_id
		) as sd on o.order_id = sd.order_id
	where 
		o.order_status <> 'canceled' and 
		o.order_delivered_customer_date <> ''
	order by 
		sd.seller_id, o.order_purchase_timestamp desc
	) as dates 
group by
	seller_id
having 
	days_between_orders <= 30
order by days_between_orders;

# Number of active sellers:
select 
	count(seller_id)
from 
	(select
		seller_id,
		datediff(max(dates.order_purchase_timestamp), max(previous_order_date)) as days_between_orders
	from 
		(select 
			sd.seller_id,
			o.order_id,
			o.order_purchase_timestamp,
			lag(o.order_purchase_timestamp ,1)
				over(partition by sd.seller_id order by o.order_purchase_timestamp) as previous_order_date
		from 
			orders o 
		join 
			(
				select
				s2.seller_id,
				i.order_id,
				count(i.order_item_id ) as order_item_count
			from 
				items i 
			join
				(
				select
					i2.order_id as order_id ,
					count(distinct i2.seller_id) as distinct_seller_count
				from 
					items i2 
				group by
					i2.order_id
				) as s1 on i.order_id = s1.order_id
			join 
				(
				select
					i2.order_id,
					i2.seller_id
				from 
					items i2 
				group by 
					order_id, seller_id 
				) as s2 on i.order_id = s2.order_id
			group by 
				i.order_id, s2.seller_id 
			order by 
				s2.seller_id, i.order_id
			) as sd on o.order_id = sd.order_id
		where 
			o.order_status <> 'canceled' and 
			o.order_delivered_customer_date <> ''
		order by 
			sd.seller_id, o.order_purchase_timestamp desc
		) as dates 
	group by
		seller_id
	having 
		days_between_orders <= 30
	order by days_between_orders) as active_seller_count;

# Number of active sellers by year, month and quarter:
select
	year(order_purchase_timestamp) as the_year,
	quarter(order_purchase_timestamp) as the_quarter,
	month(order_purchase_timestamp) as the_month,
	count(seller_id) as no_of_active_sellers
from
	(select
		seller_id,
		max(order_purchase_timestamp) as order_purchase_timestamp
	from 
		(select 
			sd.seller_id,
			o.order_id,
			o.order_purchase_timestamp,
			lag(o.order_purchase_timestamp ,1)
				over(partition by sd.seller_id order by o.order_purchase_timestamp) as previous_order_date
		from 
			orders o 
		join 
			(
				select
				s2.seller_id,
				i.order_id,
				count(i.order_item_id ) as order_item_count
			from 
				items i 
			join
				(
				select
					i2.order_id as order_id ,
					count(distinct i2.seller_id) as distinct_seller_count
				from 
					items i2 
				group by
					i2.order_id
				) as s1 on i.order_id = s1.order_id
			join 
				(
				select
					i2.order_id,
					i2.seller_id
				from 
					items i2 
				group by 
					order_id, seller_id 
				) as s2 on i.order_id = s2.order_id
			group by 
				i.order_id, s2.seller_id 
			order by 
				s2.seller_id, i.order_id
			) as sd on o.order_id = sd.order_id
		where 
			o.order_status <> 'canceled' and 
			o.order_delivered_customer_date <> ''
		order by 
			sd.seller_id, o.order_purchase_timestamp desc
		) as dates 
	group by
		seller_id
	having 
		datediff(max(order_purchase_timestamp) , max(previous_order_date)) <= 30 and 
		datediff(max(order_purchase_timestamp) , max(previous_order_date)) is not null
		) as active_seller_count 
group by 
	the_year, the_quarter, the_month
order by 
	the_year, the_quarter, the_month;

________________________________________________________________________________________________________

#Q6: What is the distribution of seller ratings on Olist, and how does this impact sales performance?

# Reviews count and percentage:
select
	review_score,
	count(*) as total_reviews,
	round(count(*) * 100 / (select count(*) from reviews r ),2) as percentage
from 
	reviews r 
group by 
	review_score
order by 
	review_score;

# To find the revenue by review score I will make two views review and payment and then by joining them on the basis of order_id I will get revenue by review score.

create or replace view review as 
select
	o.order_id as order_id,
	round(avg(r.review_score),0) as review_score
from 
	orders o 
join 
	reviews r on o.order_id = r.order_id
where 
	o.order_status <> 'canceled' and 
	o.order_delivered_customer_date <> ''
group by 
	o.order_id;


create or replace view payment as 
select 
	o.order_id as order_id,
	sum(p.payment_value) as payment_value
from 
	orders o 
join 
	payments p on o.order_id = p.order_id
where 
	o.order_status <> 'canceled' and 
	o.order_delivered_customer_date <> ''
group by 
	o.order_id;
	

select 
	r.review_score,
	coalesce(round(sum(p.payment_value),0),0) as total_payment,
	round(100*coalesce(round(sum(p.payment_value),0),0)/ all_sum.all_pay,2) as percentage
from 	
	review r
join 
	payment p on r.order_id = p.order_id
cross join 
	(select
		coalesce(round(sum(p.payment_value),0),0) as all_pay
	from
		payment p) as all_sum
group by
	r.review_score, all_pay
order by 
	r.review_score desc;
	
________________________________________________________________________________________________________

#Q7: How many customers have made repeat purchases on Olist, and what percentage of total sales do they account for?

# Total number of customers:
select 
	count(distinct c.customer_unique_id) as total_customers
from
	customers c ;

# Number of repeated customers:
select 
	count(*) as No_of_repeated_customers
from
	(select
		c.customer_unique_id,
		count(distinct order_id)
	from
		customers c 
	join
		orders o on c.customer_id = o.customer_id
	where 	
		o.order_status <> 'canceled' and 
		o.order_delivered_customer_date <> ''
	group by 
		c.customer_unique_id
	having 
		count(distinct order_id) > 1
	) as a;

# Revenue by repeated customers:
select
	round(sum(payment_value),0) as revenue_by_repeated_customers
from 
	payments p 
where 
	order_id
in 
	(select 
		order_id
	from
		orders o 
	join
	 	(
		select
			customer_id
		from
			customers c
		join
			(select 
				customer_unique_id
			from
				(select
					c.customer_unique_id,
					count(distinct order_id)
				from
					customers c 
				join
					orders o on c.customer_id = o.customer_id
				where 	
					o.order_status <> 'canceled' and 
					o.order_delivered_customer_date <> ''
				group by 
					c.customer_unique_id
				having 
					count(distinct order_id) > 1
				) a
			)as rc on c.customer_unique_id = rc.customer_unique_id
		)as r_c_o_id on o.customer_id = r_c_o_id.customer_id
	where 	
		o.order_status <> 'canceled' and 
		o.order_delivered_customer_date <> ''
	);

# To count percentage:
select 
	round(100*revenue_by_repeated_customers/total_revenue,2) as percentage_of_repeated_customers
from
	(select
		round(sum(payment_value),0) as revenue_by_repeated_customers
	from 
		payments p 
	where 
		order_id
	in 
		(select 
			order_id
		from
			orders o 
		join
		 	(
			select
				customer_id
			from
				customers c
			join
				(select 
					customer_unique_id
				from
					(select
						c.customer_unique_id,
						count(distinct order_id)
					from
						customers c 
					join
						orders o on c.customer_id = o.customer_id
					where 	
						o.order_status <> 'canceled' and 
						o.order_delivered_customer_date <> ''
					group by 
						c.customer_unique_id
					having 
						count(distinct order_id) > 1
					) a
				)as rc on c.customer_unique_id = rc.customer_unique_id
			)as r_c_o_id on o.customer_id = r_c_o_id.customer_id
		where 	
			o.order_status <> 'canceled' and 
			o.order_delivered_customer_date <> ''
		)
	) a,
	(select 
		sum(payment_value) as total_revenue
	from
		orders o 
	join
		payments p on o.order_id = p.order_id 
	where 
		o.order_status <> 'canceled' and 
		o.order_delivered_customer_date <> ''
	) b;

________________________________________________________________________________________________________

#Q8: What is the average customer rating for products sold on Olist, and how does this impact sales performance?

select 
	product_name,
	round(avg(review_score),1) as avg_review,
	count(o.order_id),
	rank() over (order by count(o.order_id) desc) as rnk
from
	orders o
join
	(select
		o.order_id,
		p.product_id,
		p.product_category_name_English as product_name
	from
		items i 
	join
		products p on i.product_id = p.product_id 
	join 
		orders o on i.order_id = o.order_id 
	where 
		o.order_status <> 'canceled' and 
		o.order_delivered_customer_date <> ''
	) pro on o.order_id = pro.order_id
join 
	(select
		o.order_id as order_id,
		avg(r.review_score) as review_score
	from
		orders o 
	join
		reviews r on o.order_id =r.order_id 
	where 
		o.order_status <> 'canceled' and 
		o.order_delivered_customer_date <> ''
	group by
		r.order_id
	) as rev on o.order_id = rev.order_id
where 
	o.order_status <> 'canceled' and 
	o.order_delivered_customer_date <> ''
group by
	product_name
order by
	avg_review desc;

________________________________________________________________________________________________________

#Q9: What is the average order cancellation rate on Olist?

select 
	o.order_status,
	count(o.order_id) as No_of_orders,
	round(100*count(o.order_id)/sum(count(order_id)) over (),2) as percentage
from
	orders o,
	(select
		count(o2.order_id) as total_orders
	from
		orders o2
	where 
		o2.order_status <> 'canceled' and 
		o2.order_delivered_customer_date <> ''
	) as to_o 
group by
	o.order_status
order by 
	percentage desc;

________________________________________________________________________________________________________
	
#Q10: Identify Products with the Most Negative Reviews.

select 
	p.product_category_name_English as product_name,
	count(r.review_score) as No_of_reviews,
	round(avg(r.review_score),2) as avg_review,
	GROUP_CONCAT(DISTINCT r.review_comment_message) AS sample_negative_comments
from
	items i 
join
	products p on i.product_id = p.product_id 
join 	
	reviews r on i.order_id = r.order_id 
where 
	r.review_score in (1,2)
group by 
	product_name
order by 	
	No_of_reviews desc;










